import telegram
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    LabeledPrice,
    InputMediaPhoto,
    WebAppInfo
)
from telegram.ext import (
    ContextTypes,
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ConversationHandler,
    CallbackQueryHandler,
    PicklePersistence,
    PreCheckoutQueryHandler)
from telegram.constants import ParseMode
import requests
import logging

from decimal import Decimal

from settings import MEDIA_DIR, TELEGRAM_TOKEN, BASE_URL, PAYMENT_TOKEN
from handlers import (
    delete_msg,
    generate_access_key,
    generate_hash_key
)

from prodamus import generate_payment_link

from defaults import zemun_path

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                     level=logging.INFO)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

# command handlers
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    r = requests.post(f'{BASE_URL}register-user/{update.message.from_user["username"]}/?chat_id={update.message.chat.id}')
    routs = requests.get(url=f'{BASE_URL}routs')

    # user with access
    if r.json().get('user', None) == 'with access':
        buttons = []
        for rout in routs.json():
            buttons.append([InlineKeyboardButton(text=rout.get('rout_name'), callback_data=f'rout_{rout.get("id")}')])
        rout_choose = await update.message.reply_text(
            f'–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞! –£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø'
            f'\n\n'
            f'–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã:',
            reply_markup=InlineKeyboardMarkup(buttons))
        context.user_data['to_delete'] = [rout_choose.id]

    # user without access
    elif r.json().get('user', None) == 'without access':

        buttons = [
        [InlineKeyboardButton('–•–æ—á—É –æ–ø–ª–∞—Ç–∏—Ç—å', callback_data='get_subscription')],
        [InlineKeyboardButton('–£ –º–µ–Ω—è –µ—Å—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥', callback_data='get_promo_subscription')],
        [InlineKeyboardButton('–£ –º–µ–Ω—è –µ—Å—Ç—å –ø–æ–¥–∞—Ä–æ—á–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç', callback_data='get_subscription_from_friend')],
        [InlineKeyboardButton('–•–æ—á—É –∫—É–ø–∏—Ç—å –ø–æ–¥–∞—Ä–æ—á–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç', callback_data='get_subscription_friend')]
               ]
        markup = InlineKeyboardMarkup(buttons)

        await update.message.reply_text(f'–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞! \n'
                                        f'–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ç—ã –Ω–µ –æ–ø–ª–∞—Ç–∏–ª(-–∞) –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –≤ –ø—Ä–æ—à–ª—ã–π —Ä–∞–∑, —Ç—ã –º–æ–∂–µ—à—å —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ '
                                        f'–ø–æ –∫–Ω–æ–ø–∫–µ —Å–Ω–∏–∑—É!üëá',
                                        parse_mode='HTML',
                                        reply_markup=markup)
    # new user
    elif r.json().get('id'):
        buttons = [[InlineKeyboardButton('–•–æ—á—É –æ–ø–ª–∞—Ç–∏—Ç—å', callback_data='get_subscription')]]
        markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text(f'–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç ¬´–¥–∞—à–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç—ã¬ª! \n'
                                        f'–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∞—Ä—à—Ä—É—Ç—É –ø–æ –ó–µ–º—É–Ω—É, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É ¬´–•–æ—á—É –æ–ø–ª–∞—Ç–∏—Ç—å¬ª. '
                                        f'–ï—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥ –∏–ª–∏ –ø–æ–¥–∞—Ä–æ—á–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç, '
                                        f'–Ω–∞–∂–∏–º–∞–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É.',
                                        parse_mode= 'HTML',
                                        reply_markup=markup)

async def activate_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    key = update.message.text
    username = update.message.from_user.username
    r = requests.post(f'{BASE_URL}users/activate/{username}/{key}')
    if r.status_code == 403 or r.status_code == 500:
        return await update.message.reply_text(f'–ü–æ—Ö–æ–∂–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {r.content}')

    routs = requests.get(url=f'{BASE_URL}routs')
    buttons = []
    for rout in routs.json():
        buttons.append([InlineKeyboardButton(text=rout.get('rout_name'), callback_data=f'rout_{rout.get("id")}')])

    markup = InlineKeyboardMarkup(buttons)

    return await update.message.reply_text('–¢–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!', reply_markup=markup)

async def check_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    r = requests.get(f'{BASE_URL}get-user/{update.message.from_user.username}')
    user = r.json()

    if user.get('access_granted'):
        routs = requests.get(url=f'{BASE_URL}routs/')
        buttons = []
        for rout in routs.json():
            buttons.append([InlineKeyboardButton(text=rout.get('rout_name'),
                                                 callback_data=f'rout_{rout.get("id")}')])

        markup = InlineKeyboardMarkup(buttons)
        rout_choose = await update.message.reply_text(
            '–£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∏ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –º–æ–∏–º —ç–∫—Å–∫—É—Ä—Å–∏—è–º',
            reply_markup=markup
        )
        context.user_data['to_delete'] = [rout_choose.id]
        return

    buttons = [
        [InlineKeyboardButton('–•–æ—á—É –æ–ø–ª–∞—Ç–∏—Ç—å', callback_data='get_subscription')],
        [InlineKeyboardButton('–£ –º–µ–Ω—è –µ—Å—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥', callback_data='get_promo_subscription')],
        [InlineKeyboardButton('–£ –º–µ–Ω—è –µ—Å—Ç—å –ø–æ–¥–∞—Ä–æ—á–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç', callback_data='get_subscription_from_friend')],
        [InlineKeyboardButton('–•–æ—á—É –∫—É–ø–∏—Ç—å –ø–æ–¥–∞—Ä–æ—á–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç', callback_data='get_subscription_friend')]
               ]
    markup = InlineKeyboardMarkup(buttons)

    return await update.message.reply_text('–ü–æ—Ö–æ–∂–µ —É —Ç–µ–±—è –µ—â—ë –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞, —Ç—ã –º–æ–∂–µ—à—å –ø–æ–ª—É—á–∏—Ç—å –µ—ë –Ω–∞–∂–∞–≤ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ!'
                                           , reply_markup=markup)

async def send_request_to_admins(update: Update, context:ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    r = requests.get(f'{BASE_URL}check_access/{update.callback_query.message.chat.username}/')
    if r.status_code != 500:
        if r.json().get('user') == 'with access':
            return await update.callback_query.message.reply_text(
                '–£ —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø! –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /routs —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–∞—Ä—à—Ä—É—Ç–æ–≤'
            )

    if query.data == 'get_subscription':
        buttons = [
            [InlineKeyboardButton("–û–ø–ª–∞—Ç–∞ —Ä–æ—Å—Å–∏–π—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π", callback_data="ru_card")],
            [InlineKeyboardButton("–û–ø–ª–∞—Ç–∞ –∑–∞—Ä—É–±–µ–∂–Ω–æ–π –∫–∞—Ä—Ç–æ–π", callback_data="noru_card")],
        ]
        markup = InlineKeyboardMarkup(buttons)

        return await update.callback_query.message.reply_text("–ö–∞–∫–æ–π –∫–∞—Ä—Ç–æ–π –±—É–¥–µ—Ç –ø—Ä–æ–≤–æ–¥–∏—Ç—å—Å—è –æ–ø–ª–∞—Ç–∞?",
                                               reply_markup=markup)


async def ru_pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "ru_card":
        invoice_desc = await update.callback_query.message.reply_text(
            '–¢—ã –ø–æ–ª—É—á–∏—à—å –¥–æ—Å—Ç—É–ø –∫ –º–∞—Ä—à—Ä—É—Ç—É, –æ–ø–ª–∞—Ç–∏–≤ –µ–≥–æ –ø–æ –∫–Ω–æ–ø–∫–µ –Ω–∏–∂–µ. '
            '–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã —Ç–µ–±—è –∂–¥—É—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –Ω–∞ –∫–∞—Ä—Ç–µ —Ç–æ—á–∫–∏ –æ—Å—Ç–∞–Ω–æ–≤–æ–∫, '
            '–∞—É–¥–∏–æ—Ä–∞—Å—Å–∫–∞–∑—ã –æ —Ç–æ–º, —á—Ç–æ —Ç–µ–±—è –±—É–¥–µ—Ç –æ–∫—Ä—É–∂–∞—Ç—å –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ '
            '–º–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è –±–æ–ª–µ–µ –≥–ª—É–±–æ–∫–æ–≥–æ –ø–æ–≥—Ä—É–∂–µ–Ω–∏—è –≤ —Ç–µ–º—É.\n\n'
            'U≈æivaj!'
        )

        invoice = await update.callback_query.message.reply_invoice(

            title='–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É',
            description='–î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç—É —Å –º–∞—Ä—à—Ä—É—Ç–æ–º –ø–æ –≥–æ—Ä–æ–¥—É, –≤ –∫–æ—Ç–æ—Ä—ã–π –≤—Ö–æ–¥—è—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –Ω–∞ –∫–∞—Ä—Ç–µ —Ç–æ—á–∫–∏ –∏ –∞—É–¥–∏–æ- –∏ —Ñ–æ—Ç–æ–º–∞—Ç–µ—Ä–∏–∞–ª—ã –∫ –∫–∞–∂–¥–æ–π –∏–∑ –Ω–∏—Ö.',
            payload='Custom-Payload',
            currency='RUB',
            prices=[LabeledPrice('–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É', 1400 * 100)],
            need_name=False,
            need_phone_number=False,
            is_flexible=False,
            provider_token=str(PAYMENT_TOKEN),
            need_email=True,
            send_email_to_provider=True,
            provider_data={
                "receipt":{
                    "items": [
                        {
                            "description": '–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –¥–∞—à–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç—ã',
                            "quantity": "1.00",
                            "amount":
                                {
                                    "value": "1400.00",
                                    "currency": "RUB"
                                },
                            "vat_code": 1
                        }

                    ]
                }
            }

        )
        context.user_data['to_delete'] = [invoice_desc.id, invoice.id]
        context.user_data['buying'] = 'self'

async def noru_pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "noru_card":
        chat_id = str(update.callback_query.message.chat.id)
        secure_hash = str(await generate_hash_key(chat_id))
        notification_link = f'http://49.13.167.190/prodamus-success/{chat_id}/{secure_hash}'
        data = zemun_path
        data['urlNotification'] = notification_link
        print(data)
        payment_link = generate_payment_link(data=data)
        print(payment_link)
        buttons = [
            [InlineKeyboardButton("–û–ø–ª–∞—Ç–∞ –∑–∞—Ä—É–±–µ–∂–Ω–æ–π –∫–∞—Ä—Ç–æ–π",
                                         web_app=WebAppInfo(url= payment_link
                                         )
                                  )
             ]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)
        await update.callback_query.message.reply_text("–î–ª—è –æ–ø–ª–∞—Ç—ã –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã–º–∏ –∫–∞—Ä—Ç–∞–º–∏, –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ",
                                                        reply_markup=reply_markup
                                                       )


async def get_subscription_for_friend(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    await update.callback_query.message.reply_text('–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –ø–æ –∫–Ω–æ–ø–∫–µ —Å–Ω–∏–∑—É, —è –ø—Ä–∏—à–ª—é —Ç–µ–±–µ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π –∫–ª—é—á, '
                                                   '–∞ —Ç–∞–∫ –∂–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –ø–æ –µ–≥–æ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏')

    invoice = await update.callback_query.message.reply_invoice(

        title='–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –¥–ª—è –¥—Ä—É–≥–∞',
        description='–î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç—É —Å –º–∞—Ä—à—Ä—É—Ç–æ–º –ø–æ –≥–æ—Ä–æ–¥—É, –≤ –∫–æ—Ç–æ—Ä—ã–π –≤—Ö–æ–¥—è—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –Ω–∞ –∫–∞—Ä—Ç–µ —Ç–æ—á–∫–∏ –∏ –∞—É–¥–∏–æ- –∏ —Ñ–æ—Ç–æ–º–∞—Ç–µ—Ä–∏–∞–ª—ã –∫ –∫–∞–∂–¥–æ–π –∏–∑ –Ω–∏—Ö.',
        payload='Custom-Payload',
        currency='RUB',
        prices=[LabeledPrice('–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É', 1400 * 100)],
        need_name=False,
        need_phone_number=False,
        need_email=True,
        is_flexible=False,
        provider_token=str(PAYMENT_TOKEN),
        send_email_to_provider=True,
        provider_data= {
            "receipt": {
                "items": [
                    {
                        "description": '–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É "–¥–∞—à–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç—ã" –¥–ª—è –¥—Ä—É–≥–∞',
                        "quantity": "1.00",
                        "amount" :
                            {
                                "value": "1400.00",
                                "currency": "RUB"
                            },
                        "vat_code" : 1
                    }

                ]
            }
        }

    )
    context.user_data['buying'] = 'friend'

async def precheckout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Answers the PreQecheckoutQuery"""
    query = update.pre_checkout_query
    # check the payload, is this from your bot?
    if query.invoice_payload != "Custom-Payload":
        # answer False pre_checkout_query
        await query.answer(ok=False, error_message="Something went wrong...")
    else:
        await query.answer(ok=True)

async def process_success_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await delete_msg(update, context, context.user_data["to_delete"])
    if context.user_data.get('buying') == 'self':
        username = update.message.from_user.username
        r = requests.post(f'{BASE_URL}users/activate/{username}')

        if r.status_code == 403 or r.status_code == 500:
            await update.message.reply_text(f'–ü–æ—Ö–æ–∂–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {r.content}')
            return
        await delete_msg(update, context, context.user_data['to_delete'])
        routs = requests.get(url=f'{BASE_URL}routs/')
        buttons = []
        for rout in routs.json():
            buttons.append([InlineKeyboardButton(text=rout.get('rout_name'),
                                                 callback_data=f'rout_{rout.get("id")}')])
        markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text('–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É –¥–æ—Å—Ç—É–ø–∞ –∫ –±–æ—Ç—É!\n\n'
                                        '–ù–∏–∂–µ —è –ø–µ—Ä–µ—á–∏—Å–ª–∏–ª –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –º–∞—Ä—à—Ä—É—Ç—ã', reply_markup=markup, parse_mode='HTML')
        del context.user_data['buying']
    elif context.user_data.get('buying') == 'friend':
        access_key = await generate_access_key(update.message.from_user.username)
        r = requests.post(f'{BASE_URL}gift_keys/?key={access_key}')
        if r.status_code == 200:
            await update.message.reply_text(
                f'–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É\n\n'
                f'–≠—Ç–æ –∫–ª—é—á –∫–æ—Ç–æ—Ä—ã–π —Ç—ã –º–æ–∂–µ—à—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–≤–æ–µ–º—É –¥—Ä—É–≥—É –∏–ª–∏ –ø–æ–¥—Ä—É–≥–µ\n\n'
                f'`{access_key}`\n\n'
                f'–¢–≤–æ–π –¥—Ä—É–≥ –º–æ–∂–µ—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–Ω–µ –∫–æ–º–∞–Ω–¥—ã /start –∏ –Ω–∞–∂–∞–≤ –∫–Ω–æ–ø–∫—É '
                f'"–£ –º–µ–Ω—è –µ—Å—Ç—å –∫–æ–¥ –æ—Ç –¥—Ä—É–≥–∞"', parse_mode=ParseMode.MARKDOWN_V2
            )
        del context.user_data['buying']


async def check_promocode_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    if update.callback_query:
        query = update.callback_query
        await query.answer()

        promo_start = await update.callback_query.message.reply_text("–í–≤–µ–¥–∏ –ø—Ä–æ–º–æ–∫–æ–¥")
        context.user_data['to_delete'] = [promo_start.id]
        return 'next__check__promo'
    else:
        promo_start = await update.message.reply_text("–í–≤–µ–¥–∏ –ø—Ä–æ–º–æ–∫–æ–¥")
        context.user_data['to_delete'] = [promo_start.id]
        return 'next__check__promo'

async def check_promocode_end(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    r = requests.get(f'{BASE_URL}promo/?source=bot&phrase={update.message.text}')

    if r.status_code != 403:
        await update.message.reply_text('–ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!')
        if r.json().get('is_percent'):
            new_price = Decimal('1400') * (Decimal('1') - Decimal(f'0.{r.json().get("percent")}'))
        else:
            new_price = r.json().get('price')
        invoice = await update.message.reply_invoice(

            title='–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É(–ü–†–û–ú–û)',
            description='–î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç—É —Å –º–∞—Ä—à—Ä—É—Ç–æ–º –ø–æ –≥–æ—Ä–æ–¥—É, –≤ –∫–æ—Ç–æ—Ä—ã–π –≤—Ö–æ–¥—è—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –Ω–∞ –∫–∞—Ä—Ç–µ —Ç–æ—á–∫–∏ –∏ –∞—É–¥–∏–æ- –∏ —Ñ–æ—Ç–æ–º–∞—Ç–µ—Ä–∏–∞–ª—ã –∫ –∫–∞–∂–¥–æ–π –∏–∑ –Ω–∏—Ö.',
            payload='Custom-Payload',
            currency='RUB',
            prices=[LabeledPrice('–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É', int(new_price) * 100)],
            need_name=False,
            need_phone_number=False,
            need_email=True,
            is_flexible=False,
            provider_token=str(PAYMENT_TOKEN),
            send_email_to_provider=True,
            provider_data={
                "receipt": {
                    "items": [
                        {
                            "description": '–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É "–¥–∞—à–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç—ã" (–ü–†–û–ú–û)',
                            "quantity": "1.00",
                            "amount":
                                {
                                    "value": f'{int(new_price)}.00',
                                    "currency": "RUB"
                                },
                            "vat_code": 1
                        }

                    ]
                }
            }

        )
        context.user_data['buying'] = 'self'
        return ConversationHandler.END

    elif r.status_code == 403:
        await update.message.reply_text(f'<b>{r.content.decode("UTF-8")}</b>\n\n'
                                        f'–ü—Ä–æ–≤–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞ –∏ –≤–≤–µ–¥–∏ –µ–≥–æ —Å–Ω–æ–≤–∞', parse_mode='HTML')
        return 'next__check__promo'

async def check_friend_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        query = update.callback_query
        await query.answer()

        await update.callback_query.message.reply_text('–î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–ª—é—á–∞, –æ—Ç–ø—Ä–∞–≤—å –µ–≥–æ –º–Ω–µ –≤ –æ—Ç–≤–µ—Ç–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏')

        return 'next__friend__key__confirmation'

async def friend_key_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):

    r = requests.get(f'{BASE_URL}gift_keys/?key={update.message.text}')

    if r.status_code == 200:
        activation = requests.post(f'{BASE_URL}users/activate/{update.message.from_user.username}')
        if activation.status_code == 200:
            await update.message.reply_text('–î–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∞—Ä—à—Ä—É—Ç–∞–º –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /routs')
        return ConversationHandler.END
    elif r.status_code == 404:
        await update.message.reply_text('–ü–æ—Ö–æ–∂–µ —Ç–∞–∫–æ–≥–æ –∫–ª—é—á–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –æ–Ω –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω, –ø—Ä–æ–≤–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å '
                                        '–Ω–∞–ø–∏—Å–∞–Ω–∏—è –∏ –ø—Ä–∏—à–ª–∏ –º–Ω–µ –µ–≥–æ —Å–Ω–æ–≤–∞')
        return 'next__friend__key__confirmation'

async def promo_check_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('–û—Ç–º–µ–Ω–∞')
    return ConversationHandler.END

async def register_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    username = update.message.from_user.username
    chat_id = update.message.chat_id
    r = requests.post(f'{BASE_URL}admins/?chat_id={chat_id}&username={username}')
    if r.status_code == 200:
        await update.message.reply_text(f'@{username}, —Ç–µ–ø–µ—Ä—å —Ç—ã –∞–¥–º–∏–Ω –∏ –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å –∑–∞—è–≤–∫–∏! –î–ª—è –ª–æ–≥–∏–Ω–∞ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: {chat_id}')
    else:
        await update.message.reply_text('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏')

async def help_command(update: Update, context:ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(f'–î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ —ç—Ç–æ \n'
                                    f'–ê –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –¥—Ä—É–≥–æ–µ \n')

async def about_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f'–ü—Ä–∏–≤–µ—Ç! '
                                    f'–≠—Ç–æ –±–æ—Ç ¬´–¥–∞—à–∏–Ω—ã –º–∞—Ä—à—Ä—É—Ç—ã¬ª. –í–º–µ—Å—Ç–µ —Å–æ –º–Ω–æ–π —Ç—ã —Å–º–æ–∂–µ—à—å –ø—Ä–æ–≥—É–ª—è—Ç—å—Å—è –ø–æ'
                                    f'–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–æ–º—É –º–∞—Ä—à—Ä—É—Ç—É –∏ —É—Å–ª—ã—à–∞—Ç—å —Ä–∞—Å—Å–∫–∞–∑ –æ —Ç–æ–º, —á—Ç–æ –≤—Å—Ç—Ä–µ—Ç–∏—à—å –Ω–∞ –ø—É—Ç–∏. –í –ª—é–±–æ–π'
                                    f'–º–æ–º–µ–Ω—Ç –º–æ–∂–µ—à—å –≤–∑—è—Ç—å –ø–∞—É–∑—É –∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –º–∞—Ä—à—Ä—É—Ç—É –ø–æ–∑–∂–µ –∏–ª–∏ –≤ –¥—Ä—É–≥–æ–π –¥–µ–Ω—å.ü•∞'
                                    f'\n'
                                    f'\n'
                                    f'–î–∞–Ω–Ω—ã–π –±–æ—Ç –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø—Ä–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–µ –∫–æ–º–∞–Ω–¥—ã <a href="https://www.quadevents.me">quadevents.me</a>',
                                    parse_mode='HTML')

# main loop for points of rout
# greeting message
async def greeting_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await delete_msg(update, context, context.user_data['to_delete'])
    user_choice = query.data.split('_')[1]

    routs = requests.get(f'{BASE_URL}routs')

    rout = list(filter(lambda rout: rout.get('id') == int(user_choice), routs.json()))[0]

    context.user_data['rout_id'] = user_choice
    first_point = requests.get(f'{BASE_URL}rout-points-first/{user_choice}')
    context.user_data['rout_point_id'] = first_point.json()[0].get('id')
    context.user_data['next_rout_point_id'] = first_point.json()[0].get('next_point', None)

    markup = InlineKeyboardMarkup([[InlineKeyboardButton('–ü—Ä–∏—Å—Ç—É–ø–∏—Ç—å', callback_data='next')]])

    msg_instructions = await update.callback_query.message.reply_text(
        f'–ù–∞—á–∞–ª–æ —ç–∫—Å–∫—É—Ä—Å–∏–∏ "{rout.get("rout_name")}"\n\n'
        f'–ü—Ä–∏–≤–µ—Ç!\n\n'
        f'–ï—Å–ª–∏ —ç—Ç–æ —Ç–≤–æ—è –ø–µ—Ä–≤–∞—è —ç–∫—Å–∫—É—Ä—Å–∏—è, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–∑–Ω–∞–∫–æ–º—å—Å—è '
        f'—Å —Ñ–æ—Ä–º–∞—Ç–æ–º –¥–∞–ª—å–Ω–µ–π—à–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π\n\n'
        f'–ü–µ—Ä–≤—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –±—É–¥–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –æ—Ç –î–∞—à–∏, –≥–¥–µ –æ–Ω–∞ –∫—Ä–∞—Ç–∫–æ –ø—Ä–æ–π–¥–µ—Ç—Å—è –ø–æ —Ç–æ–º—É, —á—Ç–æ —Ç–µ–±—è –æ–∂–∏–¥–∞–µ—Ç –Ω–∞ —ç–∫—Å–∫—É—Ä—Å–∏–∏.\n\n '
        f'–ö–∞–∫ —Ç–æ–ª—å–∫–æ —Å –Ω–∏–º –æ–∑–Ω–∞–∫–æ–º–∏—à—å—Å—è '
        f'–∏–ª–∏ —Ä–µ—à–∏—à—å –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å, –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É <b>"–ü—Ä–∏—Å—Ç—É–ø–∏—Ç—å"</b> —ç—Ç–æ –∑–∞–ø—É—Å—Ç–∏—Ç —ç–∫—Å–∫—É—Ä—Å–∏—é \n\n'
        f'–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ —è —Å–∫–∏–Ω—É —Ç–µ–±–µ —Ç–æ—á–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ –ø—Ä—è–º–æ –≤ —á–∞—Ç–µ, –∞ —Ç–∞–∫ –∂–µ –≤—Å–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã\n\n'
        f'–¢—ã –º–æ–∂–µ—à—å –ø—Ä–µ—Ä–≤–∞—Ç—å —ç–∫—Å–∫—É—Ä—Å–∏—é –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–µ–π –ø–æ–∑–∂–µ - '
        f'—è –∑–∞–ø–æ–º–Ω—é –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É –∏ —Ç–µ–±–µ –Ω–µ –ø—Ä–∏–¥–µ—Ç—Å—è –º–µ–Ω—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—Ç—å!\n\n'
        f'<i>–ï—Å–ª–∏ –≤—Å—ë –∂–µ —Ä–µ—à–∏—à—å –∑–∞–∫–æ–Ω—á–∏—Ç—å —ç–∫—Å–∫—É—Ä—Å–∏—é —Å–æ–≤—Å–µ–º, –Ω–∞–ø–∏—à–∏ –º–Ω–µ <b>/end</b> –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç </i>',
        parse_mode='HTML',
        reply_markup=markup)

    msg_intro = await update.callback_query.message.reply_text('–ö —Å–ª–æ–≤—É, –î–∞—à–∏–Ω—ã —Å–æ–æ–±—â–µ–Ω–∏—è-—Ä–∞—Å—Å–∫–∞–∑—ã –≤—ã–≥–ª—è–¥—è—Ç —Ç–∞–∫ üòä')

    msg_intro_voice = await update.callback_query.message.reply_voice(
        voice=MEDIA_DIR+'/audio/'+first_point.json()[0].get('audio'),
        caption=first_point.json()[0].get('description', '–æ—à–∏–±–æ—á–∫–∞'),
        protect_content=True
    )
    context.user_data['to_delete'] = [msg_instructions.id, msg_intro.id, msg_intro_voice.id]
    return 'map_point'

# map point message for rout
async def map_materials_point(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == 'next':
        current_point = requests.get(f'{BASE_URL}rout-points/{context.user_data["rout_id"]}/{context.user_data["next_rout_point_id"]}')

        point_data = current_point.json()
        # await delete_msg(update, context, context.user_data['to_delete'])

        # set next point from prev step to current point
        context.user_data['rout_point_id'] = context.user_data["next_rout_point_id"]

        # set next point to next point from point data
        context.user_data["next_rout_point_id"] = point_data[0].get('next_point', None)
        cords = point_data[0].get('map_point').strip('][').split(', ')
        text_map = await update.callback_query.message.reply_text('–ö–∞—Ä—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ç–æ—á–∫–∏')
        map_msg = await update.callback_query.message.reply_location(
            longitude=cords[0],
            latitude=cords[1],
            protect_content=True
        )

        context.user_data['to_delete'] = [map_msg.id, text_map.id]

        if context.user_data['next_rout_point_id'] == None:
            markup = InlineKeyboardMarkup([[InlineKeyboardButton('–ó–∞–∫–æ–Ω—á–∏—Ç—å —ç–∫—Å–∫—É—Ä—Å–∏—é', callback_data='end')]])
        else:
            markup = InlineKeyboardMarkup([[InlineKeyboardButton('–°–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞', callback_data='next')]])

        # photo or media group
        photos = point_data[0].get('images').strip("[]").replace(" ", "").replace("'", "").split(',')
        if len(photos) == 1:
            img_msg = await update.callback_query.message.reply_photo(
                photo=open(MEDIA_DIR + '/images/' + photos[0], 'rb'),
                protect_content=True
            )
            context.user_data['to_delete'].append(img_msg)
        elif len(photos) > 1:
            medias = []
            for photo in photos:
                medias.append(InputMediaPhoto(media=open(MEDIA_DIR + '/images/' + photo, 'rb')))
            img_msg = await update.callback_query.message.reply_media_group(media=medias,  protect_content=True)
            for msg in img_msg:
                context.user_data['to_delete'].append(msg)
        # voice msg
        voice_msg = await update.callback_query.message.reply_voice(
            voice=MEDIA_DIR + '/audio/' + point_data[0].get('audio'),
            reply_markup=markup,
            caption=point_data[0].get('description', '–æ—à–∏–±–æ—á–∫–∞'),
            protect_content=True
        )
        context.user_data['to_delete'].append(voice_msg)
        # next_point_msg = await update.callback_query.message.reply_text('–°–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞', )
        if point_data[0].get('next_point', None):
            return 'map_point'
        return 'end'

# async def audio_text_point(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     query = update.callback_query
#     await query.answer()
#
#     if query.data == 'next':
#         await delete_msg(update, context, context.user_data['to_delete'])
#         current_point = requests.get(
#             f'{BASE_URL}rout-points/{context.user_data["rout_id"]}/{context.user_data["next_rout_point_id"]}')
#
#         point_data = current_point.json()
#
#         return 'map_point'

async def end_rout(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        await update.callback_query.message.reply_text('–ë–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ')
        await update.callback_query.message.reply_text('–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–∫—Å–∫—É—Ä—Å–∏–π –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /routs')
        return ConversationHandler.END
    await update.message.reply_text('–ë–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ')
    await update.message.reply_text('–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–∫—Å–∫—É—Ä—Å–∏–π –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /routs')
    return ConversationHandler.END

if __name__ == '__main__':
    persistence = PicklePersistence(filepath="conversations")
    app = Application.builder().token(TELEGRAM_TOKEN).read_timeout(20).persistence(persistence).build()

    conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(greeting_message, pattern=r"^rout_\d*$")],
        states= {
            'map_point': [CallbackQueryHandler(map_materials_point)],
            # 'text_audio': [CallbackQueryHandler(audio_text_point)],
            'end': [CallbackQueryHandler(end_rout)]
        },
        fallbacks=[CommandHandler('end', end_rout)]
    )

    promo_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(check_promocode_start, pattern=r'^get_promo_subscription$')
        ],
        states= {
            'next__check__promo': [MessageHandler(filters.TEXT & ~filters.COMMAND, check_promocode_end)]
        },
        fallbacks=[CommandHandler('cancel', promo_check_cancel)],
        allow_reentry=True
    )

    access_activation_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(check_friend_code, pattern='get_subscription_from_friend')],
        states={
            'next__friend__key__confirmation': [MessageHandler(filters.TEXT & ~filters.COMMAND, friend_key_confirmation)]
        },
        fallbacks=[CommandHandler('cancel', promo_check_cancel)],
        allow_reentry=True

    )

    # Commands
    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CommandHandler('about', about_command))
    app.add_handler(CommandHandler('check', check_subscription))
    app.add_handler(CommandHandler('routs', check_subscription))
    app.add_handler(CommandHandler('reg1q2w3e4r5t6y', register_admin))


    app.add_handler(CallbackQueryHandler(send_request_to_admins, pattern=r'^get_subscription$'))
    app.add_handler(CallbackQueryHandler(ru_pay, pattern=r"^ru_card$"))
    app.add_handler(CallbackQueryHandler(noru_pay, pattern=r"noru_card"))

    # app.add_handler(MessageHandler(filters.Regex(r'^\b[a-fA-F0-9]{64}\b$') & ~filters.COMMAND, activate_subscription))

    # Payments
    app.add_handler(CommandHandler('buy', send_request_to_admins))
    app.add_handler(CallbackQueryHandler(get_subscription_for_friend, pattern='get_subscription_friend'))
    app.add_handler(PreCheckoutQueryHandler(precheckout_callback))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT & ~filters.COMMAND, process_success_payment))

    app.add_handler(promo_conv)
    app.add_handler(conv)
    app.add_handler(access_activation_conv)

    print('starting polling')
    app.run_polling()